Of the avaliable software development models, our team has chosen the waterfall development model. Though previously, we intended to tackle the project in a spiral type iterative fashion, and we have chosen user stories over use cases - which was more suitable for an iterative than an incremental design pattern like the waterfall pattern, the extremely short time of the project and the structure of the assignments was such that we ended up doing waterfall in practice. 

As before, opportunistic model is only suitable for extremely small scale coding projects without a client. This project fits neither bill.

As before, we'd have chosen spiral, but the fact of the matter is that due to the structure of the assignments in this class as well as the miniscule amount of time we had, we ended up completing only a single run of the spiral cycle, which is waterfall in practice. As such, for this time scale, it turns out waterfall is a more realistic development model, hence why we effectively chose it.

We attempted concurrant process model to some degree, but due to our project being novel and experimental for us, it was only somewhat concurrantly built. Concurrant engineering is best if the project is well known, and dividing up the components of the project easy. Our project is not a well known problem, and as such, dividing it up wasn't easy, thus we didn't utilize concurrant process model.

As for the scrum model, though it might have been a good fit, it was not the method used in practice, due to the structure of the assignments and of the implementation in practice. Scrum is an iterative model focused on high communication with our client and iterative design. Due to our short amount of time, iterative design turned out to not be a good idea, since a single scrum cycle is all the time we have to actually develop the application, and such a single cycle is incremental when taken alone.

Though we originally set out to implement spiral methodology to our development process, we ultimately chose waterfall because it was more realistic for our time frame, we didn't throughly know how to do risk/cost assessment, and the structure of the course.

However, waterfall is a sub-component of spiral. For the purposes of this class, we ended up doing waterfall only, as the time of this class was such that only one cycle of spiral could be done. We intend to continue with this project after the class, so for the purposes of this assignment and of the class, we have done the waterfall development method, but our prior statement about intending to do spiral, or at least some form of agile development methodology, still applies.

SCRUM VERSION JUSTIFICATION:

Of the avalible software development models, our team has chosen the scrum development model. This choice comes from the nature of our project and our client avaliability - our project is new and novel to all of us, requiring a high degree of experimentation and clarification. Furthermore, we are able to communicate with our client by email on a daily basis if need be, and a weekly basis in person as well. The project size is also considerable.

Firstly, based off these aspects of our project, most incremental models are not ideal. Incremental models are best when we can get a definite idea of what we want from our client and know what we can or cannot do. Furthermore, they tend to be based off a heavy initial requirements gathering phase with a client, followed by an implementation phase where client feedback is impossible or not needed. Concurrant and waterfall style both fall under this incremental category. However, in our project, we did not have a clear, definitive idea of what our client wants. This project is also novel and experimental, and as such we do not have a clear sense of what we can/cannot do and how to do so. Finally, we can meet with our client on a weekly basis and communicate on a daily basis - to follow an incremental model would thus squander this advantage. As such, neither incremental model has been chosen.

Opportunistic model is best on tiny projects, preferably one without a client. We have a client, and our project is not small, being more than a hundred lines of code. As such, the opportunistic model is a bad fit for our project and is not chosen.

We had considered choosing the Spiral model at first, and at first it seemed like a good fit. Spiral is ideal for long term projects with occasional periodic communication with our client. However, it also requires that we know how to do risk assessment, which we had yet to learn, and it is made of short waterfall bursts, which possess all of the downsides of waterfall within the one burst. As our project time is incredibly short as well, for the purposes of this class, it turns out that spiral is not a good fit - we did not know risk assessment, nor did we have the time to make use of the iteration desired and given by spiral.

This leaves the scrum model. In the scrum model, we gather requirements into a project backlog, and then with communicaton and client-centric feedback, we work on tackling and handling each requirement within the backlog, with changes simply being more additions to the backlog. Scrum can be applied for any length of time, short or long, and being an agile methodology it allows for significant room to experiment and adjust requirements as greater understanding of the requirements and of our capacities, and of our client's desires comes up. This seems ideal for our team, where we can communicate with our client very often and adjust as needed. Indeed, in practice scrum is how our software development progressed. We also have intentions of continuing with the project after SENG, since we are working with a real world client, and as such the flexible timescale of SCRUM as opposed to Spiral further add to its value. As such, we chose the SCRUM method.